{
    "collab_server" : "",
    "contents" : "#' Simulation setup\n#'\n#' This function applies \\code{rule} (which takes in parameter settings and outputs\n#' a synthetic dataset) and \\code{criterion} (which takes a synthetic dataset and outputs\n#' the results from estimators) to all the rows of \\code{paramMat} (which is a matrix\n#' that contains different parameter settings for each row). The distinction between\n#' \\code{rule} and \\code{criterion} is only made by the user, as the user can design\n#' exactly the same simulation that uses one but not the other.\n#'\n#' The input to \\code{rule} must be a vector (a row from \\code{paramMat}), while\n#' the input to \\code{criterion} must be first the output of \\code{rule} and second\n#' a vector (the same row from \\code{paramMat}). Both these functions is allowed\n#' to output lists.\n#'\n#' The output to \\code{simulation_generator} is a list, one element for each\n#' row of \\code{paramMat}. Each element of the list is typically a list or\n#' a matrix. This depends on how the user set up what \\code{criterion} returns.\n#'\n#' The function has a \\code{tryCatch} call, so if an error happens, the result for that\n#' trial and row of \\code{paramMat} will be an \\code{NA}.\n#'\n#' The remaining inputs for \\code{simulation_generator} are cosmetic.\n#'\n#' \\code{as_list} is a boolean, where if \\code{TRUE},\n#' mandates that the \\code{trials} results for each row of \\code{paramMat}\n#' is returned as a list. If \\code{FALSE}, then the results are returned as a matrix.\n#'\n#' @param rule function\n#' @param paramMat matrix\n#' @param criterion function\n#' @param trials number of trials for each row\n#' @param cores number of cores\n#' @param as_list boolean\n#'\n#' @return list\n#' @export\nsimulation_generator <- function(rule, criterion, paramMat, trials = 10,\n cores = NA, as_list = T){\n\n  if(!is.na(cores)) doMC::registerDoMC(cores = cores)\n\n  res <- lapply(1:nrow(paramMat), function(x){\n    cat(paste0(\"\\nRow \", x, \" started!\\n\"))\n\n    fun <- function(y){\n      if(trials > 10 && y %% floor(trials/10) == 0) cat(\"*\")\n      set.seed(y)\n      tryCatch({\n        criterion(rule(paramMat[x,]), paramMat[x,])\n      }, error = function(e){\n        NA\n      })\n    }\n\n    if(is.na(cores)){\n      if(as_list){\n        vec <- lapply(1:trials, fun)\n      } else {\n        vec <- sapply(1:trials, fun)\n      }\n    } else {\n    trial <- 0 #debugging reasons\n      vec <- foreach::\"%dopar%\"(foreach::foreach(i = 1:trials), fun(trial))\n      if(!as_list) vec <- .adjustFormat(vec)\n    }\n  })\n\n  names(res) <- sapply(1:nrow(paramMat), function(x){\n    paste0(paramMat[x,], collapse = \"-\")})\n\n  res\n}\n\n.adjustFormat <- function(lis){\n  len <- sapply(lis, length)\n  if(length(unique(len)) != 1) return(lis)\n\n  ncol <- length(unique(len))\n  if(ncol == 1) return(as.numeric(unlist(lis)))\n\n  vec <- as.numeric(unlist(lis))\n  matrix(vec, ncol = ncol, byrow = T)\n}\n",
    "created" : 1511702814738.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1006657181",
    "id" : "CBB90497",
    "lastKnownWriteTime" : 1511704209,
    "last_content_update" : 1511704209783,
    "path" : "~/Dropbox/Collaboration and People/Kathryn Roeder - private/simulation/simulation/R/base.R",
    "project_path" : "R/base.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}